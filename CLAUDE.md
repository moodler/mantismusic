# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Mantis Music is a self-hosted, Spotify-style artist discography web application. Music is managed as files and folders under `/music`, compiled to JSON by a Python build script, and served as a vanilla JS single-page app. A Flask admin UI provides browser-based metadata editing. A native macOS app bundles everything into a standalone `.app`.

## Architecture

**Static Site (frontend):**
- `index.html` — Single-page app entry point template (also has favicon, discography.js script tag)
- `js/app.js` — All application logic (data loading, rendering, filtering, audio player, queue, navigation)
- `css/style.css` — Complete styling with CSS custom properties for theming
- `site/` — Self-contained deployable directory (generated by build script)
  - `site/discography.json` — Compiled music database
  - `site/discography.js` — Same data as `window._discographyData` for `file://` protocol support
  - `site/js/`, `site/css/` — Copied from source
  - `site/music` — Symlink to parent directory for audio/image access

**Build Pipeline (`build_music_json.py`):**
- Reads music folder structure (tracks/, collections/, artist/)
- Prepares `site/` directory: copies js/, css/, creates music symlink
- Compiles to `site/discography.json` and `site/discography.js`
- Generates `site/feed.rss` and `site/feed/*.html` (per-track pages for RSS readers)
- Generates `index.html` (at DATA_DIR root) with OpenGraph/Twitter meta tags and cache-busting hashes
- Copies artist profile to `site/og-image.jpg` for social sharing
- Auto-links streaming URLs via Spotify, Apple Music, Tidal, and Deezer APIs
- Auto-detects MP3 duration via mutagen and writes back to track.md
- Optimizes oversized cover images to 1024x1024 using `sips` (macOS), preserving originals as `raw-{filename}`
- Config: `config.json` — site title, site URL, Spotify API credentials, deploy destination (gitignored)

**Path Resolution (`paths.py`):**
- Central module separating APP_DIR (bundled code) from DATA_DIR (user data/music folder)
- When running from source, both resolve to the script's parent directory
- When running as a PyInstaller `.app`, APP_DIR is `sys._MEIPASS` and DATA_DIR comes from the `MANTIS_DATA_DIR` environment variable
- DATA_DIR IS the music folder (contains tracks/, collections/, artist/ directly)
- SITE_DIR = DATA_DIR / 'site' (self-contained deployable output)
- Exports all path constants used by admin.py and build_music_json.py

**Admin UI:**
- `admin.py` — Flask app serving at localhost:5001. Imports all paths from `paths.py`
- `templates/` — Jinja2 templates for dashboard, track editor, collection editor, artist editor, settings page
- Static asset routes serve `/js/`, `/css/`, `/music/` from the correct directories (APP_DIR or DATA_DIR)
- Preview button builds then opens `index.html` via `file://` URL
- Build & Deploy button builds then rsyncs `site/` directory (with `--copy-links` to follow symlinks)
- Image uploads support paste and file picker for jpg, png, gif, webp

**macOS App:**
- `mantis_app.py` — PyWebView wrapper. Prompts for a data directory on first run, creates the directory structure if empty, sets `MANTIS_DATA_DIR`, and launches the Flask admin in a native window
- `build_app.sh` — PyInstaller build script. Bundles templates, js, css, index.html, paths.py, build_music_json.py. Converts `icon.png` to `icon.icns` for the app icon (reconverts when source is newer)
- Links within the app must NOT use `target="_blank"` (opens Safari instead of staying in pywebview)

**Data Flow:**
1. Artist manages files in the data directory (tracks/, collections/, artist/, config.json)
2. `build_music_json.py` prepares `site/` and compiles discography.json, RSS feed, feed pages, and index.html
3. Frontend loads the JSON (via fetch or pre-loaded `window._discographyData` for file:// access) and renders the player
4. Audio files are accessed via `site/music` symlink pointing to parent directory
5. Deploy rsyncs `site/` directory with `--copy-links` to follow symlinks and copy actual files

**Key State Variables in app.js:**
- `discographyData` — Raw loaded JSON
- `allTracks` — Flattened track list (filtered by search/tags/year)
- `currentView` — Active navigation view ('tracks', 'collections', 'about')
- `navigationHistory` — Stack for back-button navigation between views
- `currentTrack`, `currentRelease` — Currently playing track and its parent release
- `queue` — Playback queue array of { track, release } objects

## Data Directory Structure

The data directory IS the music folder (no intermediate `music/` subdirectory):

```
data_directory/           # User's chosen folder (or project root when running from source)
├── artist/
│   ├── artist.md         # YAML frontmatter: name, social links. Body: bio text (markdown supported)
│   ├── profile.jpg       # Square profile image (also used as favicon and OG image)
│   └── banner.png        # Wide banner image (NOT processed by image optimizer)
├── tracks/
│   └── song_name/
│       ├── track.md      # YAML frontmatter: title, duration, tags, credits, streaming URLs. Body: description
│       ├── song_name.mp3 # Audio file (MP3 for streaming)
│       ├── song_name.wav # Lossless audio (optional, offered as download)
│       ├── song_name.jpg # Cover art (optional, optimized to 1024x1024 if oversized)
│       ├── raw-song_name.jpg  # Original high-res cover (auto-created, not deployed)
│       └── song_name.txt # Lyrics plain text (optional)
├── collections/
│   └── album_name/
│       ├── collection.md # YAML frontmatter: title, type (album/ep), tracks list, streaming URLs. Body: description
│       ├── album_name.jpg  # Cover art (optimized to 1024x1024 if oversized)
│       └── raw-album_name.jpg  # Original high-res cover (auto-created, not deployed)
├── config.json           # Site title, site URL, Spotify API credentials, deploy destination
└── site/                # Generated by build script — self-contained deployable site
    ├── discography.json  # Compiled music data
    ├── discography.js    # Same data for file:// protocol support
    ├── js/, css/         # Copied from source
    ├── music -> ../      # Symlink to parent for audio/image access
    ├── feed.rss          # RSS feed
    └── feed/             # Per-track HTML pages for RSS readers
```

Collections reference tracks by folder slug. Tracks not in any collection appear as standalone singles.

## Important Implementation Notes

- `find_file()` in build script skips files starting with `.`, `raw-`, or `banner`
- `findTrackBySlug()` in app.js searches nested collection tracks first, then standalone singles (avoids slug collisions between EPs and their child tracks)
- `textToHtml()` in app.js supports markdown links `[text](url)`, **bold**, *italic*, and auto-links bare URLs
- Cache-busting: build appends `?v={md5hash}` to js/css/discography.js references in index.html
- Image optimizer uses macOS `sips` command — only runs once per image (skips if `raw-` version exists)
- Deploy uses rsync with `--copy-links` to follow the music symlink and `--exclude raw-*` to skip originals

## Development

```bash
python3 build_music_json.py    # Rebuild JSON, RSS, OG tags, optimize images
python3 -m http.server 8000    # Serve the site locally (or just open index.html in browser)
python3 admin.py               # Run admin UI on port 5001
bash build_app.sh              # Build native macOS .app
```

Dependencies (in requirements.txt): `pyyaml`, `mutagen`, `flask`, `requests`, `pywebview`, `pyinstaller`.

# Generic instructions

## Workflow Orchestration

### 1. Plan Mode Default

* Enter plan mode for ANY non-trivial task (3+ steps or architectural decisions)
* If something goes sideways, STOP and re-plan immediately – don't keep pushing
* Use plan mode for verification steps, not just building
* Write detailed specs upfront to reduce ambiguity

### 2. Subagent Strategy

* Use subagents liberally to keep main context window clean
* Offload research, exploration, and parallel analysis to subagents
* For complex problems, throw more compute at it via subagents
* One task per subagent for focused execution

### 3. Self-Improvement Loop

* After ANY correction from the user: update `tasks/lessons.md` with the pattern
* Write rules for yourself that prevent the same mistake
* Ruthlessly iterate on these lessons until mistake rate drops
* Review lessons at session start for relevant project

### 4. Verification Before Done

* Never mark a task complete without proving it works
* Diff behavior between main and your changes when relevant
* Ask yourself: "Would a staff engineer approve this?"
* Run tests, check logs, demonstrate correctness

### 5. Demand Elegance (Balanced)

* For non-trivial changes: pause and ask "is there a more elegant way?"
* If a fix feels hacky: "Knowing everything I know now, implement the elegant solution"
* Skip this for simple, obvious fixes – don't over-engineer
* Challenge your own work before presenting it

### 6. Autonomous Bug Fixing

* When given a bug report: just fix it. Don't ask for hand-holding
* Point at logs, errors, failing tests – then resolve them
* Zero context switching required from the user
* Go fix failing CI tests without being told how

## Task Management

1. **Plan First**: Write plan to `tasks/todo.md` with checkable items
2. **Verify Plan**: Check in before starting implementation
3. **Track Progress**: Mark items complete as you go
4. **Explain Changes**: High-level summary at each step
5. **Document Results**: Add review section to `tasks/todo.md`
6. **Capture Lessons**: Update `tasks/lessons.md` after corrections

## Core Principles

* **Simplicity First**: Make every change as simple as possible. Impact minimal code.
* **No Laziness**: Find root causes. No temporary fixes. Senior developer standards.
* **Minimal Impact**: Changes should only touch what's necessary. Avoid introducing bugs.

